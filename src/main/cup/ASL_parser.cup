package asl.input;

import java_cup.runtime.*;
import asl.input.ASLLexer;
import asl.input.ASLConsumer;
import asl.model.core.*;
import asl.model.core.functions.*;
import asl.model.system.ASLObjectsFactory;
import asl.model.system.SequenceFacade;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

scan with {: return super.scan(); :};

parser code {:
  ASLConsumer consumer;
  public ASLParser(Scanner lex, ASLConsumer consumer_) {
    super(lex, new ComplexSymbolFactory());
    consumer = consumer_;
  }

  private static List<ASLObject> makeList(ASLObject... args) {
    return new ArrayList<>(Arrays.asList(args));
  }
:};


/* ------------Declaration of Terminals and Non Terminals Section----------- */
   
terminal _SEMICOLON;
terminal _COMMA;
terminal _LPAR;
terminal _RPAR;
terminal _STAR;
terminal _SLASH;
terminal _PERCENT;
terminal _PLUS;
terminal _MINUS;
terminal _EQ;
terminal _GT;
terminal _GTE;
terminal _LT;
terminal _LTE;
terminal _EQQ;
terminal _NEQ;
terminal _AND;
terminal _OR;
terminal _NOT;
terminal UMINUS;

terminal Undef UNDEF;
terminal IntegerAtom INTCONST;
terminal DoubleAtom DOUBLECONST;
terminal BooleanAtom TRUE, FALSE;
terminal Variable VAR, ATTRVAR;
terminal QNameAtom QNAME;

non terminal program;
non terminal List<ASLObject> arg_commalist, arg_commalist_opt, plus_expr, mult_expr, gt_expr, gte_expr, lt_expr, lte_expr;
non terminal ASLObject statement, expr, arg;


/* -------------Precedence and Associatively of Terminals Section----------- */

precedence left _OR;
precedence left _AND;
precedence left _EQQ, _NEQ;
precedence left _GT, _GTE, _LT, _LTE;
precedence left _PLUS, _MINUS;
precedence left _STAR, _SLASH, _PERCENT;
precedence right _EQ, _NOT, UMINUS;


/* ----------------------------Grammar Section-------------------- */
   
program ::=
    /* empty */
    | program statement:stmt                          {: consumer.consume(stmt); :}
    ;

statement ::=
    expr:e _SEMICOLON                                 {: RESULT = e; :}
    ;

expr ::=
    VAR:v                                             {: RESULT = v; :}
    | VAR:lhs _EQ expr:rhs                            {: RESULT = new SetqFunction(List.of(lhs, rhs)); :}
    | _LPAR expr:e _RPAR                              {: RESULT = e; :}
    | QNAME:fname _LPAR arg_commalist_opt:al _RPAR    {: RESULT = ASLObjectsFactory.makeFunctionCall(fname.value(), al); :}
    | INTCONST:atom                                   {: RESULT = atom; :}
    | DOUBLECONST:atom                                {: RESULT = atom; :}
    | TRUE:atom                                       {: RESULT = atom; :}
    | FALSE:atom                                      {: RESULT = atom; :}
    | UNDEF:und                                       {: RESULT = und; :}
    | QNAME:atom                                      {: RESULT = atom; :}
    | expr:e0 _SLASH    expr:e1                       {: RESULT = new DivFunction(List.of(e0, e1)); :}
    | expr:e0 _PERCENT  expr:e1                       {: RESULT = new ModFunction(List.of(e0, e1)); :}
    | plus_expr:list                                  {: RESULT = new AddFunction(list); :}
    | expr:e0 _MINUS    expr:e1                       {: RESULT = new SubFunction(List.of(e0, e1)); :}
    | mult_expr:list                                  {: RESULT = new MulFunction(list); :}
    | gt_expr:list                                    {: RESULT = new GtFunction(list); :}
    | gte_expr:list                                   {: RESULT = new GteFunction(list); :}
    | lt_expr:list                                    {: RESULT = new LtFunction(list); :}
    | lte_expr:list                                   {: RESULT = new LteFunction(list); :}
    | _MINUS:op expr:e0                               {: RESULT = new UMinusFunction(List.of(e0)); :} %prec UMINUS
    ;

arg_commalist_opt ::=
    arg_commalist:al                                  {: RESULT = al; :}
    | /* empty */                                     {: RESULT = makeList(); :}
    ;

arg_commalist ::=
    arg_commalist:list _COMMA arg:a                   {: list.add(a); RESULT = list; :}
    | arg:a                                           {: RESULT = makeList(a); :}
    ;

arg ::=
    expr:e                                            {: RESULT = e; :}
    ;

plus_expr ::=
    plus_expr:list _PLUS expr:e                       {: list.add(e); RESULT = list; :}
    | expr:e0      _PLUS expr:e1                      {: RESULT = makeList(e0, e1); :}
    ;

mult_expr ::=
    mult_expr:list _STAR expr:e                       {: list.add(e); RESULT = list; :}
    | expr:e0      _STAR expr:e1                      {: RESULT = makeList(e0, e1); :}
    ;

gt_expr ::=
    gt_expr:list _GT expr:e                           {: list.add(e); RESULT = list; :}
    | expr:e0    _GT expr:e1                          {: RESULT = makeList(e0, e1); :}
    ;

gte_expr ::=
    gte_expr:list _GTE expr:e                         {: list.add(e); RESULT = list; :}
    | expr:e0     _GTE expr:e1                        {: RESULT = makeList(e0, e1); :}
    ;

lt_expr ::=
    lt_expr:list _LT expr:e                           {: list.add(e); RESULT = list; :}
    | expr:e0    _LT expr:e1                          {: RESULT = makeList(e0, e1); :}
    ;

lte_expr ::=
    lte_expr:list _LTE expr:e                         {: list.add(e); RESULT = list; :}
    | expr:e0     _LTE expr:e1                        {: RESULT = makeList(e0, e1); :}
    ;
